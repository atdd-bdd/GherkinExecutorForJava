## Design Flow

GherkinExecutor was created to make it easy to implement tests for
business rules, domain terms, and flow that incorporates domain classes.

### Test, Data, and Glue

There are responsibilities assigned to the test, data, and glue classes.

The test class represents a set of unit tests, one for each scenario.  It initializes
the lists that are passed to the glue code,  The lists are of either String
or class that you define with a Data statement.

The data classes represent the classes use to represent the tables.  They form
the parameter passing mechanism between the test methods and the glue methods.
Since the attributes are declared, constructors, toString(), and other methods
are created. (You could add toJSON(), fromJSON(), toCSV(), etc)
and put the creation code into Translate).

There can be one or two classes that hold the same data.  One class contains the
attributes in String form. This is the test-glue interface.  The other is
a class that contains the attributes in internal form (int, Date, etc.)  This is the
interface to the production code.

The glue code receives data from the test code.  You can convert the string class
to the internal class.  You use whatever values are necessary for input and output
to and from the production methods.   And you assert for whatever values you want.

### General Flow

The general flow is:

* Read the feature file. Eliminate comment lines and blank lines.  Insert
  any `Include` files.
* Parse a line and process it.
  ** `Feature` starts the process with creating the test and glue files.
  ** `Scenario` initiates the creation of a test in the test file.  
  ** `Given` and the other keywords initiate the creation of a glue function.
  ** `Import` sets up the imports
  ** `Data` initiates the creation of one string class and an optional internal class.

The step functions, one for each type of object being passed to a glue function,
are generated by the individual steps.

The initial version of Translator was written for Kotlin.  It was converted to Java and
other facets were added. It is currently being converted back
to Kotlin, Python, and C++.

### The differences between GherkinExecutor and Other Frameworks

Gherkin Executor's goal was to create an easy-to-use testing framework for
business rules, calculations, and domain terms.  So the emphasis was passing
values by tables.

Every feature file creates its own package.  The tests and the associated data
files are within that package.  Glue functions are created for each feature.
rather than being shared between all features.  If you need to use the same
function in multiple features

* create a feature that contains that glue function.
* Make up a file that contains all the Data statements that are required by the glue code
* and `Include` that file in every feature that needs it.
* Call the common glue code from the glue code for the feature.
* Decide whether you want to construct a new glue object for each call or use the same one

It all depends on what the production code needs to do.

# Maintenance

In summary , there are multiple tests applied to `Translate`. 

- Gherkin Full - to see if test and glue file creation remain the same (except for what is expected due  to change)
  If the expected changes are correct, then copy the .tmpl and the test file into the corresponding .exp files

- Run all unit tests (in the test directory) with logging and compare against expected - to see if output of tests remains the same (except for what is expected due to the changes)   

- Compare manually the log.txt file to the `log.exp` file for Feature_Full_Test 
  If change are as expected, then copy the `log.txt` file into `log.exp` file.

## Maintainers

There are no standard unit tests for this program. This program generates
code based on the feature file.  The exact formatting of that code is
not important.   The fact that the code executes as required is important.

There are two tests
for each facet.  The first is whether the generated code produced the
correct behavior.   This is checked by translating the feature file for
a facet (.e.g. Import) and executing the generated test.   The trace should
show the calls to the glue code and the values that are passed.

If that test is successful, the feature file is added to the full_test.featurex
file.  The Feature_Gherkin_Translator_Full_Test is run.  It translates
the full_test.featurex and compares the outputs to .exp files.  If no output
behavior has changed, it passes.  If the test fails, you examine the
Test file and the .exp file for differences.  If one of the included feature files
has changed, then it should show the appropriate difference.   If the
difference looks correct, copy the new test or glue.tmpl file into the .exp files.

The output of the tests (without any implementation) is checked by running Translate for full_test.featurex with logIt and inTest true.

Then the Feature_Full_Test log.txt is compared to the log.exp.   They should be the same, unless the change that is made should have altered them.   

Note sometimes a line ending difference (LF to CRLF) occurs.  You can check by
comparing the files manually.








