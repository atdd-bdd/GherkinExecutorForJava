### Difference in parameterized test and a Gherkin Table 

```
    @ParameterizedTest
    @MethodSource("provideTemperaturesForConversion")
    void testFahrenheitToCelsius(int fahrenheit, int expectedCelsius) {
        assertEquals(expectedCelsius, TemperatureConverter.fahrenheitToCelsius(fahrenheit));
    }

    private static Stream<Arguments> provideTemperaturesForConversion() {
        return Stream.of(
            Arguments.of(32, 0),
            Arguments.of(212, 100),
            Arguments.of(-40, -40)
        );
    }
}
class TemperatureConverter {
   static int FahrenheitToCelsius(int fahrenheit) {
        return ((fahrenheit - 32) * 5) / 9;
    }
}
```

```agsl
Scenario: Temperature 
# Business rule , Calculation 
Calculation Convert F to C # ListOfObject TemperatureCalculation 
| F    | C    | Notes       |
| 32   | 0    | Freezing    |
| 212  | 100  | Boiling     |
| -40  | -40  | Below zero  |

Data TemperatureCalculation
| Name   | Default  | DataType  | Notes  |
| F      | 0        | Int       |        |
| C      | 0        | Int       |        |
| Notes  |          | String    |        |

This is the glue code, which is generated by Translate.  You
only need to add the same assertEquals.  Although in this case, 
you can add the note as a message.   

    void Calculation_Convert_F_to_C(List<TemperatureCalculation> values) {
        for (TemperatureCalculation value : values) {
            try {
                TemperatureCalculationInternal i = value.toTemperatureCalculationInternal();
                assertEquals(i.c, TemperatureCalculations.convertFahrenheitToCelsius(i.f), i.notes);;
        
            } catch (Exception e) {
                System.err.println("Argument Error " + value.toString() + TemperatureCalculationInternal.toDataTypeString());
            }
        }
    }

```
###  Whitespace
All comments (line being with `#`) are ignored.  All blank lines are
ignored.  If you begin a line with other than a keyword or a table or a string,
you will get an warning. 

## Include 
You can include another file in a feature file. The included file should 
not have a `Feature` statement in it.  If it does, a warning will be generated.
If the file is a `.csv` file, it will be converted to a table.   
```
Feature: Include

Scenario: Some scenario here
Given a string
"""
Include "string.inc"
"""
Then a table
Include "TableExample.csv"
```
You can include any text, including `Data` statements (useful 
for reusing) common data layouts.  

## Design Flow 
GherkinExecutor was created to make it easy to implement tests for
business rules, domain terms, and flow that incorporates domain classes.

There are reponsiblities assigned to the test, data, and glue classes. 

The test class represents a set of unit tests, one for each scenario.  It initializes
the lists that are passed to the glue code,  The lists are of either Strinng
or class that you define with a Data statement.   

The data classes represent the classes use to represent the tables.  They form
the parameter passing mechanism between the test methods and the glue methods. 
Since the attributes are declared, constructors, toString(), and other methods 
are created. (You could add toJSON(), fromJSON(), toCSV(), etc)
and put the creation code into Translate).   

There can be one or two classes that hold the same data.  One class contains the 
attributes in String form. This is the test-glue interface.  The other is
a class that contains the attributes in internal form (int, Date, etc.)  This is the 
inteface to the production code. 

The glue code receives data from the test code.  You can convert the string class
to the internal class.  You use whatever values are necessary for input and output
to and from the production methods.   And you assert for whatever values you want.

The general flow is: 
* Read the feature file. Eliminate comment lines and blank lines.  Insert 
any `Include` files.  
* Parse a line and process it. 
** `Feature` starts the process with creating the test and glue files.
** `Scenario` initiates the creation of a test in the test file.  
** `Given` and the other keywords initatiate the creation of a glue function.
** `Import` sets up the imports
** `Data` initiates the creation of one string class and an optional internal class.

The step functions, one for each type of object being passed to a glue function,
are generated by the individual steps.   


### Style 
You can begin with a `Data` statement that just lists the 
attributes (fields) and default values.  The glue function
will be passed a list of objects that contain string values.
It's up to you to convert the values as desired. 

### The differences between GherkinExecutor and Other Frameworks
GherkinExecutor's goal was to create an easy to use testing framework for 
business rules, calculations, and domain terms.  So the emphasis was passing
values by tables.    

Every feature file creates its own package.  The tests and the associated data
files are within that package.  Glue functions are created for each feature.
rather than being shared between all features.  If you need to use the same
function in multiple features
* create a feature that contains that glue function.
* Make up a file that contains all the Data statements that are required by the glue code
* and `Include` that file in every feature that needs it.
* Call the common glue code from the glue code for the feature.   
* Decide whether you want to construct a new glue object for each call or use the same one

It all depends on what the production code needs to do.  

## Converting a Gherkin feature file 
You can convert an existing Gherkin feature file to one usuable by GherkinExecutor 
in a few steps.

If there is no data passed to a step, then nothing needs to be done. 
If a step is passed a multiline string, no change. 
If a step has a value specified within it, move that value to a new line 
after the step and surround it with `|`,   e.g.  `|4|`
If the step uses a table with a header that represents the names of the fields, 
create a `Data` stetement with the names of those fields and default values. 
* The values will be passed as strings 
* Put `# ListOfObject _className_` on the end of the step line.
* If the old glue code used a `transpose` for a table, enter that on the step in the feature file. 
*    e.g. # ListOfObject _className_ transpose`  

Now if your production code uses primitives or abstract data types, add
data types to the `Data` statement.    

To implement the tests, move the glue code in the existing glue steps to 
the corresponding functions in the new glue class.   Now you'll need to
convert the glue parameter to that expected by the old glue code or 
alter the code to use the new parameter name;   

If your test code depends upon "fancy stuff" of your existing framework, 

### Try It Out 
Download the GherkinExecutor (for your language) from github.  
Go to the Feature_Examples package in the test directory.  Run 
Feature_Examples. Examine the console output.   This package 
demonstrates a calculation, a domain term, and a collection that having methods
(filter and sum for that filter) applied to it. 

The other example to run is` Feature_Tic_Tac_TOe_Game`. In this example, 
the internal representation of a game is converted to a string and
compared to the table which is passed to the glue code as a string. 
You can see graphically where the two disagree (if they do)

### Use values in GUI
You could use the values in the table as the input values to a User Interface (UI).
The Given could set up the state.  The When could printout the values
to input, and the Then could check that the state has changed appropriately. 

## Define 
There is one more facet that is being developed.  It may have
some use, depending on your context.   With a `define`, you specify 
the value of a constant once, e.g. 
```
Define 
| Name       | Value | Notes                 |
| HIGH_VALUE | 100   | Highest allowed input |
| LOW_VALUE  | 1     | Lowest allowed input  |
Now whever `HIGH_VALUE` appears in data in a table (other than the
header), it will be replaced by 100. For example:
```
Given this data:
| ID  | Value     |
| A   | HIGH_DATA |
| B   | LOW_DATA  |

will be treated as:
Given this data:
| ID  | Value     |
| 1   | 100       |
| B   | 1         |

This is useful if the Define terms are meaningful to someone reading 
the feature file. 

### Calculated Values

| Name           | Value | Notes               |
| AVERAGE_VALUE  | (LOW_DATA +HIGH_DATA)/2    | 
``````

This will be passed at "(1 + 100)/2)';```

Given this data:
| ID  | Value     |
| A   | HIGH_DATA |
| B   | LOW_DATA  |
| C   | AVERAGE_VALUE |

will be treated as:
Given this data:
| ID  | Value     |
| 1   | 100       |
| B   | 1         |
| C   | (1 + 100)/2 |

Now you could have the Data statement be of dataType ComputeInt
and inside that class, a method would take the string, calculate the
value, and return it.   

For Java, you can check out: If you want to do calcuations with these defines, you could 
use sing the ScriptEngineManager and ScriptEngine classes from the javax.script package:

## Maintainers
There are no standard unit tests for this program. This program generates
code based on the feature file.  The exact formatting of that code is 
not important.   The fact that the code executes as required is importnat. 

There are two test
for each facet.  The first is whether the generated code produced the
correct behavior.   This is checked by translating the feature file for 
a facet (.e.g Import) and executing the generated test.   The trace should
shows the calls to the glue code and the values that are passed.  

If that test is successful, the feature file is added to the full_test.feature 
file.  The Feature_Gherkin_Translator_Full_Test is run.  It translates 
the full_test.feature and compares the outputs to .exp files.  If no output 
behavior has changed, it passes.  If the test failes, you examine the 
Test file and the .exp file for differences.  If one of the included feature files
has changed, then it should show the appropriate difference.   If the 
difference looks correct, copy the new test or glue.tmpl file into the .exp files. 

Note sometimes a line ending difference (LF to CRLF) occurs.  You can check by 
comparing the files manually.   

